Кратко: проверка, не повлияли ли изменения кода на существовавшую функциональность.

Подробнее: когда команда устраняет баг, добавляет новую функцию, или улучшает имеющуюся, то, разумеется, при этом будет изменен исходный код приложения. Известно, что даже совсем небольшое изменение исходного кода может привести (и часто приводит) к целому “букету” новых багов. Поэтому тестировщики должны искать и устранять эти “побочные эффекты” — и для этого предназначены регрессионные тесты (“регрессы” на жаргоне тестировщиков).
![[Pasted image 20230321111347.png]]

### Коррекционное

Простая форма “регресса”, не требующая больших усилий и затрат. Выполняется в случаях, когда в существующую _кодовую базу_ не вносятся большие изменения, а лишь какая-то единичная новая функция. Задача — протестировать существующую функциональность, скорее всего даже “старыми” тест-кейсами без создания новых.

### Выборочное

“Селективное регрессионное” анализирует, как сочетается новый код с существующим; например, когда в код включаются новые значимые переменные и функции, проводится быстрая проверка результатов этого.

### Прогрессивное

Тест-кейсы по схеме прогрессивного регрессионного теста: когда в продукт вносятся лишь небольшие изменения/улучшения, новые тест-кейсы не затрагивают существующий код.

### Полное

Как уже говорилось выше, даже небольшие изменения в коде способны сильно повлиять на продукт; тем более если код изменился значительно — тогда делают _полное регрессионное_ тестирование, которое должно исправить все “побочные эффекты”.

### Частичное

Когда в коде есть небольшие изменения и нужно экономить время; направлено только на _критические баги_.

### Полное повторное регрессионное

Иначе называемое _retest-all regression_. Повторное выполнение всех тест-кейсов. Из-за большого объема работы такое делается редко.

### Регрессионное юнит-тестирование

Код модулей-юнитов «изолируется» и тестируется, а все другие запросы/интеграции/зависимости «отключены». Выполняется, когда нагрузка (или трафик) на приложение не очень большие, обычно в ночное время.

## Подходы

Подход, или общая стратегия регрессионного тестирования, чтобы «регресс» прошёл успешно:

-   Повторное выполнение всех имеющихся тестов. После релиза тестировщики должны повторно проверить «проблемные области». Это может быть непросто, особенно если речь идёт о ручных тестах, и значит нужна автоматизация.
-   Приоритеты. Не менее половины регрессионных тестов должны быть посвящены критически важной функциональности.
-   А далее — сложные функции, затрагивающие многие компоненты, качество которых тоже нужно внимательно проверять.
-   Исследовательское тестирование при добавлении новых функций.
-   Продуманная автоматизация, для ускорения процесса и улучшения продуктивности.
-   [Рендомное тестирование](https://testengineer.ru/chto-takoe-obezjane-testirovanie-chem-otlichaetsja-ot-ad-hoc-testirovanija-chto-takoe-gorilla-test/), проводимое самыми опытными тестировщиками.

## Регрессионные тест-кейсы

Известно, что заметное количество дефектов появляется в приложении на этапе деплоя. Это увеличивает затраты времени и труда QA-команды. Поэтому важно подобрать правильные тест-кейсы, базируясь на пользовательских требованиях.

1.  **Тест-кейсы, ориентированные на часто возникающие баги**. Один-единственный коммит способен “поломать” всю функциональность. Также, дефекты имеют свойство “кучковаться” в нескольких модулях. Тестировщик должен помнить [основные закономерности](https://testengineer.ru/sem-glavnyh-principov-testirovaniya/), подбирая тест-кейсы, ориентированные на самые частые дефекты и [самые критические области](https://testengineer.ru/princip-pareto-v-testirovanii/). Для этого нужно хорошо знать приложение, его бизнес-логику, и разумеется иметь большой опыт в “регрессах”.
2.  **Тест-кейсы, ориентированные на критически важные функции**. Основная функциональность приложения должна быть всегда “в фокусе”. Например, банковское приложение должно пройти регрессионные тесты платежной подсистемы, навигации, поисковой подсистемы, и подобное.
3.  Разумеется, тест-кейсы **с последними обновлениями кода**, и они должны проводиться неоднократно. Часто обновляемые участки кода — цель регрессионных тест-кейсов по умолчанию.
4.  **Пользовательский интерфейс** и вообще области, видимые пользователю при первом взгляде на приложение/сайт. Особое внимание должно быть уделено логотипу бренда, изображениям, тексту на кнопках, и подобные важные “визуальные” вещи. Такие тест-кейсы имеют приоритет чуть ниже, чем предыдущие в этом списке, но тоже необходимы, ведь это [комфорт пользователя](https://testengineer.ru/usability-testing/), а значит его привязанность к продукту.
5.  Связанные с **интеграцией** модулей. Функциональность одного компонента может зависеть от функциональности другого. Например, если функция компонента С2 зависит от компонента С1, и С1 модифицирован, это повлияет на С2. Поэтому нужны «регрессионные тесты интеграционного характера».
6.  **Большие сложные** тест-кейсы могут вызывать проблемы и быть в целом непродуктивными. Нужно варьировать тестовые техники, грамотно подбирать нужные в данном случае.
7.  **Учитывать** [**риски**](https://testengineer.ru/chto-takoe-risk-testirovanie/#:~:text=%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B5%20%D1%80%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%20(risk,%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9%20%D0%B1%D0%B0%D0%B7%D0%B8%D1%80%D1%83%D0%B5%D1%82%D1%81%D1%8F%20%D0%BD%D0%B0%20%D0%B2%D0%B5%D1%80%D0%BE%D1%8F%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D1%80%D0%B8%D1%81%D0%BA%D0%BE%D0%B2.). В этом подходе тест-кейсы приоритизируются исходя из рисков; понятно, что риски возникают после обновлений критически важных частей кода.

## Лучшие практики

-   С внедрением новых функций нужно грамотно корректировать регрессионные тест-сьюты, и в их составе те тесты которые проверяют “старую” функциональность

-   Проверка функций и возможностей, наиболее активно применяемых пользователями, и включение их в кейсы, чтобы контролировать их функциональность

-   Применение специальных инструментов/фреймворков

-   Обновление тест-дизайнов, анализируя фидбек разработчиков и пользователей

-   Автоматизация, экономящая время и деньги, ускоряющая релиз

-   При возможности, перенос части регрессионных тестов в облачные платформы